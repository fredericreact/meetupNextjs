# NextJS

```javascript
import MeetupList from '../components/meetups/MeetupList'
const HomePage = () => {
return <MeetupList meetups={DUMMY_MEETUPS}/>
}


export default HomePage

```

## _app.js File

Components is a prop that holds the actual page content that should be rendered
pageProps are specific props related to the page

So _app.js will be the actual page content of our different pages, it will change depending on the page where we are

```javascript
import '../styles/globals.css'


function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}


export default MyApp

```

So if I wrap <Component> with <Layout>, all pages will be wrapped with this layout component.

```javascript
import Layout from '../components/layout/Layout'
import '../styles/globals.css'


function MyApp({ Component, pageProps }) {
  return <Layout>
  <Component {...pageProps} />
  </Layout>
}


export default MyApp

```

## router.push

It pushes a new page and is the equivalent of using the link component

```javascript
function showDetailsHandler() {
    router.push('/'+props.id)
  }

```

## useEffect
useEffect will execute after the component function is executed.

So the first time the component is rendered, it will load an empty array.

Then useEffect will execute, then this component function will execute again because state changed and it will re-render the list with the actual data.

So there will be 2 component render cycles

And because of that, there is an issue with SEO, because in the page source, the html content , the actual data is missing because they are only rendered in the second component execution cycle. 

But the pre rendered html page generated by Nextjs doesn't wait for this second cycle, it always takes the result of the first render cycle.

### Before using useEffect

```javascript
import MeetupList from '../components/meetups/MeetupList'




const DUMMY_MEETUPS = [
    {
      id: 'm1',
      title: 'A First Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 5, 12345 Some City',
      description: 'This is a first meetup!'
    },
    {
      id: 'm2',
      title: 'A Second Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 10, 12345 Some City',
      description: 'This is a second meetup!'
    }
  ];


const HomePage = () => {


return <MeetupList meetups={DUMMY_MEETUPS}/>
}


export default HomePage

```

![image](https://user-images.githubusercontent.com/104289891/214276502-e313e9fc-57a0-4246-bfd2-274dcdbbe9e3.png)


### After using useEffect

```javascript
import MeetupList from '../components/meetups/MeetupList'
import {useState, useEffect} from 'react'


const DUMMY_MEETUPS = [
    {
      id: 'm1',
      title: 'A First Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 5, 12345 Some City',
      description: 'This is a first meetup!'
    },
    {
      id: 'm2',
      title: 'A Second Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 10, 12345 Some City',
      description: 'This is a second meetup!'
    }
  ];


const HomePage = () => {
  const [loadedMeetups, setLoadedMeetups] = useState([])


  useEffect(()=>{
    setLoadedMeetups(DUMMY_MEETUPS);
  })


return <MeetupList meetups={DUMMY_MEETUPS}/>
}


export default HomePage

```

![image](https://user-images.githubusercontent.com/104289891/214276738-7fbd26be-bdfe-4374-869c-7e08a9ae8abc.png)


Nextjs Pre-rendering takes a snapshot of the first component render cycle as its content

Nextjs has 2 forms of pre-rendering : 

- static generation

- server-side rendering

## static generation

The most recommended way.

Page component is pre-rendered when you build your application , when you build for production.

Page is not pre-rendered when request reaches server.

By default : 

So after it is deployed, this pre render does not change. 

So if data is updated, and pre rendered page needs to change, you need to start that build process again.

So this could be an issue, because i would not get the latest data available on my home page. For example, I would not have the latest meetups on my home page. So this method is best for personal blogs.

With getStaticProps function, it will execute this in the prerendering process, before rendering the component function. 
It will not call your component function directly

This code is executed during the build process not on the server and not on client side

It only works in page components



```javascript
import MeetupList from '../components/meetups/MeetupList'


const DUMMY_MEETUPS = [
    {
      id: 'm1',
      title: 'A First Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 5, 12345 Some City',
      description: 'This is a first meetup!'
    },
    {
      id: 'm2',
      title: 'A Second Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 10, 12345 Some City',
      description: 'This is a second meetup!'
    }
  ];


const HomePage = (props) => {


return <MeetupList meetups={props.meetups}/>
}


export async function getStaticProps(){
  return {
    props:{
      meetups: DUMMY_MEETUPS
    }
  }
}


export default HomePage

```

To solve the outdated data issue, you can add ‘revalidate’ property with a number of seconds.

It will regenerates the page every x seconds, if there are requests for this page. 

Not just generate during the build process. It will re-pregenerate on the server after deployment.


```javascript
import MeetupList from '../components/meetups/MeetupList'


const DUMMY_MEETUPS = [
    {
      id: 'm1',
      title: 'A First Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 5, 12345 Some City',
      description: 'This is a first meetup!'
    },
    {
      id: 'm2',
      title: 'A Second Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 10, 12345 Some City',
      description: 'This is a second meetup!'
    }
  ];


const HomePage = (props) => {


return <MeetupList meetups={props.meetups}/>
}


export async function getStaticProps(){
  return {
    props:{
      meetups: DUMMY_MEETUPS
    },
    revalidate: 10
  }
}


export default HomePage

```

## Server side rendering

Des fois , meme si ca update regularly avec revalidate, c’est pas suffisant, tu veux que ca update a chaque requete.

Cette fonction ne va pas s’executer pendant le build process, mais tout le temps sur le serveur apres deployment.

```javascript
import MeetupList from '../components/meetups/MeetupList'


const DUMMY_MEETUPS = [
    {
      id: 'm1',
      title: 'A First Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 5, 12345 Some City',
      description: 'This is a first meetup!'
    },
    {
      id: 'm2',
      title: 'A Second Meetup',
      image: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
      address: 'Some address 10, 12345 Some City',
      description: 'This is a second meetup!'
    }
  ];


const HomePage = (props) => {


return <MeetupList meetups={props.meetups}/>
}


export async function getServerSideProps(context) {
  const req = context.req;
  const res = context.res;
  return {
    props: {
      meetups: DUMMY_MEETUPS
    }
  }
}


export default HomePage

```

## getStaticProps for a dynamic page 

1. You can access to the params
2. If you use getStaticProps for a dynamic page, you need to use getStaticPaths.
Why ? Because the pages are pre-rendered in the build process but the pages are requested through the params in the url after the deployment. Therefore, you need to pregenerate the pages for all possible ID. 
Fallback is used in order to know if all ids are input in the code. If yes, no need to have fallback, put false. If no, need to have a fallback, in case user enters an id not listed put true.
3. For the console.log in getStaticProps, you see it in the command line, not browser, because getStaticProps runs during build time, during development, it is run on the server side

```javascript
import MeetupDetail from "../../components/meetups/MeetupDetail"


const MeetupDetails = () => {


    return (
        <MeetupDetail
            image='https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg'
            title='A First Meetup'
            address='Some Street'
            description='Meetup description'


        />
    )
}




export async function getStaticPaths(){
    return {
        fallback: false,
        paths: [
            {
                params: {
                    meetupId: 'm1',
                },
            },
            {
                params: {
                    meetupId: 'm2',
                },
            },


        ]
    }


}


export async function getStaticProps(context) {


    const meetupId = context.params.meetupId;


    console.log(meetupId);


    return {
        props: {
            meetupData: {
            image:'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Stadtbild_M%C3%BCnchen.jpg/1280px-Stadtbild_M%C3%BCnchen.jpg',
            title:'A First Meetup',
            address:'Some Street',
            description:'Meetup description',
            id: meetupId,
            }
        }
    }
}


export default MeetupDetails

```
# Introducing API Routes

Nextjs allows to create backend api together with our front-end react app in the same project.

## POST 

1. you first need to Create an api folder in pages folder which will be the backend, server side

2. Then in this the back end part, store this data in a database : connect to MongoDB

```javascript
npm install mongodb
```

```javascript
import { MongoClient } from 'mongodb';


async function handler (req,res) {
    if (req.method === 'POST') {
        const data = req.body;


        const client = await MongoClient.connect('mongodb+srv://fredericreact:fredericreact@cluster0.p9ub0xq.mongodb.net/meetups?retryWrites=true&w=majority')


        const db = client.db();


        const meetupsCollection = db.collection('meetups');


        const result = await meetupsCollection.insertOne({data})


        console.log(result)


        client.close()


        res.status(201).json({message: 'meetup inserted'})


    }
}


export default handler;

```
3. Send the http request from the front end when the form is submitted

```javascript
import NewMeetupForm from '../../components/meetups/NewMeetupForm'
import { useRouter } from 'next/router'


const NewMeetupPage = () =>{
    const router = useRouter();
    async function addMeetupHandler (enteredMeetupData) {
       const response = await fetch('/api/new-meetup',
       {
        method: 'POST',
        body: JSON.stringify(enteredMeetupData),
        headers: {
            'Content-Type':'application/json'
        }
       })


       const data = await response.json()


       console.log(data)


       router.push('/')
    }


    return <NewMeetupForm onAddMeetup={addMeetupHandler}/>
}


export default NewMeetupPage;

```

## GET All data

Pas besoin de faire la meme manip, a savoir passer par notre propre api route/path. 

Vu que la donnee sera via getStaticProps et recuperee during le build

We need to map meetups because in mongoDB, the id is an ‘objectID’, so if we want to use it, we need to convert it into a string.

```javascript
import {MongoClient} from 'mongodb'


import MeetupList from '../components/meetups/MeetupList'


const HomePage = (props) => {


return <MeetupList meetups={props.meetups}/>
}


export async function getStaticProps(){


  const client = await MongoClient.connect('mongodb+srv://fredericreact:fredericreact@cluster0.p9ub0xq.mongodb.net/meetups?retryWrites=true&w=majority')


  const db = client.db();


  const meetupsCollection = db.collection('meetups');


  const meetups = await meetupsCollection.find().toArray();


  client.close()


  return {
    props: {
  meetups: meetups.map(meetup => ({
    title: meetup.data.title,
    address: meetup.data.address,
    image: meetup.data.image,
    id: meetup._id.toString()
  }))
},
    revalidate: 10
  }
}


export default HomePage

```

## One specific data

We need to map meetups because in mongoDB, the id is an ‘objectID’, so if we want to use it, we need to convert it into a string.

On the other hand, if we want to do a search in mongoDB using the id in the url/params, we need to convert it into ‘ObjectID’

```javascript
import MeetupDetail from "../../components/meetups/MeetupDetail"
import {MongoClient, ObjectId} from 'mongodb'


const MeetupDetails = (props) => {


    return (
        <MeetupDetail
            image={props.meetupData.image}
            title={props.meetupData.title}
            address={props.meetupData.address}
            description={props.meetupData.description}


        />
    )
}




export async function getStaticPaths(){


    const client = await MongoClient.connect('mongodb+srv://fredericreact:fredericreact@cluster0.p9ub0xq.mongodb.net/meetups?retryWrites=true&w=majority')


        const db = client.db();


        const meetupsCollection = db.collection('meetups');


        const meetups = await meetupsCollection.find({}, {_id: 1}).toArray();


        client.close()


    return {
        fallback: false,
        paths: meetups.map((meetup)=> ({
            params: { meetupId: meetup._id.toString()},
        }))    
       
    }


}


export async function getStaticProps(context) {


    const meetupId = context.params.meetupId;


    const client = await MongoClient.connect('mongodb+srv://fredericreact:fredericreact@cluster0.p9ub0xq.mongodb.net/meetups?retryWrites=true&w=majority')


        const db = client.db();


        const meetupsCollection = db.collection('meetups');


        const selectedMeetup = await meetupsCollection.findOne({ _id: ObjectId(meetupId)});
       
        console.log(selectedMeetup)


        client.close()


    return {
        props: {
           meetupData: {
            id: selectedMeetup._id.toString(),
            title: selectedMeetup.data.title,
            address: selectedMeetup.data.address,
            image: selectedMeetup.data.image,
            description: selectedMeetup.data.description,
           }
        }
    }
}


export default MeetupDetails

```

# Add <Head> MetaData

Let Search engines get the metadata
Show users a nice title in the tab 

```javascript
import {MongoClient} from 'mongodb'
import Head from 'next/head'
import MeetupList from '../components/meetups/MeetupList'
import {Fragment} from 'react'


const HomePage = (props) => {


return (
<Fragment>
<Head>
  <title>React Meetups</title>
  <meta
    name='description'
    content='Browse Meetups'
  />
</Head>
<MeetupList meetups={props.meetups}/>
</Fragment>
)}


// export async function getServerSideProps(context) {
//   const req = context.req;
//   const res = context.res;
//   return {
//     props: {
//       meetups: DUMMY_MEETUPS
//     }
//   }
// }


export async function getStaticProps(){


  const client = await MongoClient.connect('mongodb+srv://fredericreact:fredericreact@cluster0.p9ub0xq.mongodb.net/meetups?retryWrites=true&w=majority')


  const db = client.db();


  const meetupsCollection = db.collection('meetups');


  const meetups = await meetupsCollection.find().toArray();


  client.close()


  return {
    props: {
  meetups: meetups.map(meetup => ({
    title: meetup.data.title,
    address: meetup.data.address,
    image: meetup.data.image,
    id: meetup._id.toString()
  }))
},
    revalidate: 10
  }
}


export default HomePage

```

Animating React Apps

Here instead of hiding the modal smoothly using the ternary (we used the ternary in order to remove modal from html when hidden to have a clean HTML), it instantly hides it because React doesn’t wait for the animation/transition

```javascript
import React, { Component } from "react";


import "./App.css";
import Modal from "./components/Modal/Modal";
import Backdrop from "./components/Backdrop/Backdrop";
import List from "./components/List/List";


class App extends Component {
  state = {
    modalIsOpen: false
  }


  showModal = () => {
    this.setState({modalIsOpen: true})
  }


  closeModal = () => {
    this.setState({modalIsOpen: false})
  }


  render() {
    return (
      <div className="App">
        <h1>React Animations</h1>
        {this.state.modalIsOpen ? <Modal show={this.state.modalIsOpen} closed={this.closeModal}/> : null}
        {this.state.modalIsOpen ? <Backdrop show={this.state.modalIsOpen} /> : null}
        <button className="Button" onClick={this.showModal}>Open Modal</button>
        <h3>Animating Lists</h3>
        <List />
      </div>
    );
  }
}


export default App;



```

To solve this, we have some tools : 

https://reactcommunity.org/react-transition-group/ 

```javascript
npm install react-transition-group --save
```
Use the Transition component with :

- in property will define if the component is shown or not

- state has 4 states , entering, entered, exiting, exited


```javascript
import React, { Component } from "react";
import Transition from 'react-transition-group/Transition'
import "./App.css";
import Modal from "./components/Modal/Modal";
import Backdrop from "./components/Backdrop/Backdrop";
import List from "./components/List/List";


class App extends Component {
  state = {
    modalIsOpen: false,
    showBlock : false
  }


  showModal = () => {
    this.setState({modalIsOpen: true})
  }


  closeModal = () => {
    this.setState({modalIsOpen: false})
  }


  render() {
    return (
      <div className="App">
        <h1>React Animations</h1>
        <button
        className="Button"
        onClick={() =>
        this.setState(prevState => ({ showBlock: !prevState.showBlock}))}
        >
        Toggle
        </button>
        <br/>
       <Transition
       in={this.state.showBlock}
       timeout={300}
       mountOnEnter
       unmountOnExit
       >
        {state => (
          <div style ={{
          backgroundColor: "red",
          width: 100,
          height: 100,
          margin: 'auto',
          transition: 'opacity 1s ease-out',
          opacity: state === 'exiting' ? 0 : 1
        }}/>


        )}
        </Transition>
        {this.state.modalIsOpen ? <Modal show={this.state.modalIsOpen} closed={this.closeModal}/> : null}
        {this.state.modalIsOpen ? <Backdrop show={this.state.modalIsOpen} /> : null}
        <button className="Button" onClick={this.showModal}>Open Modal</button>
        <h3>Animating Lists</h3>
        <List />
      </div>
    );
  }
}


export default App;
```

`<TransitionGroup>` can be used in places where you output lists
